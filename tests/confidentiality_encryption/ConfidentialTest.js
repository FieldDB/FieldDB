"use strict";

var Confidential;
try {
  /* globals FieldDB */
  if (FieldDB) {
    Confidential = FieldDB.Confidential;
  }
} catch (e) {}
Confidential = Confidential || require("./../../api/confidentiality_encryption/Confidential").Confidential;

var atob = atob || require("atob");
var btoa = btoa || require("btoa");
var SAMPLE_COMPLEX_OBJECT = require("./../../api/corpus/corpus.json");
var specIsRunningTooLong = 5000;

describe("Confidential: as a language consultant I want to be able to give data and have my data remain confidential", function() {

  it("should be able to use btoa and atob", function() {
    var message = "this is a sample confidential translation";

    expect(btoa(message)).toEqual("dGhpcyBpcyBhIHNhbXBsZSBjb25maWRlbnRpYWwgdHJhbnNsYXRpb24=");
    expect(btoa(atob(message))).toEqual("thisisasampleconfidentialtranslation");
  });

  it("should encrypt and decrypt strings", function(done) {
    var message = "this is a sample confidential translation";
    var confidential = new Confidential({
      "filledWithDefaults": true
    });
    confidential.alwaysReplyToPrompt = "phoneme";
    confidential.debug("Getting the decryptedMode will trigger it to prompt the user to confirm their identity.", confidential.decryptedMode);

    expect(confidential.whenReady).toBeDefined();
    confidential.whenReady.then(function() {
      expect(confidential.decrypt(confidential.encrypt(message))).toEqual(message);
    }, function(error) {
      expect(error).toBeUndefined();
    }).fail(function(error) {
      expect(error).toBeUndefined();
    }).done(done);
  }, specIsRunningTooLong);

  it("should let the app set the top secret encryption key", function(done) {
    var message = "this is a sample confidential translation";
    var confidential = new Confidential();
    confidential.alwaysReplyToPrompt = "phoneme";
    confidential.debug("Getting the decryptedMode will trigger it to prompt the user to confirm their identity.", confidential.decryptedMode);

    confidential.secretkey = "thisisnormallyatopsecretautogeneratedkey";
    confidential.whenReady.then(function() {
      expect(confidential.decrypt(confidential.encrypt(message))).toEqual(message);
    }, function(error) {
      expect(error).toBeUndefined();
    }).fail(function(error) {
      expect(error).toBeUndefined();
    }).done(done);
  }, specIsRunningTooLong);

  it("should let the app send in the encryption key", function() {
    var confidential = new Confidential({
      secretkey: "thisisnormallyatopsecretautogeneratedkey"
    });
    expect(confidential.secretkey).toEqual("thisisnormallyatopsecretautogeneratedkey");
  });

  it("should decrypt complex data", function(done) {
    var confidential = new Confidential({
      secretkey: Confidential.secretKeyGenerator()
    });
    confidential.alwaysReplyToPrompt = "phoneme";
    confidential.debug("Getting the decryptedMode will trigger it to prompt the user to confirm their identity.", confidential.decryptedMode);
    // confidential.debugMode = true;

    confidential.whenReady.then(function() {
      var message = JSON.parse(JSON.stringify(SAMPLE_COMPLEX_OBJECT));
      expect(confidential.decrypt(confidential.encrypt(message)).datumFields.length).toEqual(16);
      message = ["zero", "one", "two", "three"];
      expect(confidential.decrypt(confidential.encrypt(message))).toEqual(message);
      expect(confidential.decrypt(confidential.encrypt(message))[1]).toEqual("one");
    }, function(error) {
      expect(error).toBeUndefined();
    }).fail(function(error) {
      expect(error).toBeUndefined();
    }).done(done);

  }, specIsRunningTooLong);

  describe("confirm users identity", function() {

    it("should trigger a promise if not in decryptedMode", function(done) {
      var message = "this is a sample confidential translation";
      var confidential = new Confidential({
        "filledWithDefaults": true
      });
      confidential.alwaysReplyToPrompt = "phoneme";

      var syncronousresult = confidential.decrypt(confidential.encrypt(message));
      expect(syncronousresult).toBeUndefined();

      expect(confidential.whenReady).toBeDefined();
      confidential.whenReady.then(function() {
        var syncronousresultagain = confidential.decrypt(confidential.encrypt(message));
        expect(syncronousresultagain).toEqual(message);
      }, function() {
        expect(false).toBeTruthy();
      }).done(done);

    }, specIsRunningTooLong);

  });

});
