/* globals window, localStorage, Android, navigator */
var FieldDBObject = require("./../FieldDBObject").FieldDBObject;
var Activity = require("./../activity/Activity").Activity;
var Authentication = require("./../FieldDBObject").FieldDBObject;
var Corpus = require("./../corpus/Corpus").Corpus;
var DataList = require("./../data_list/DataList").DataList;
var Import = require("./../import/Import").Import;
var Search = require("./../search/Search").Search;
var Session = require("./../FieldDBObject").FieldDBObject;
var Router = require("./../Router").Router;
var User = require("./../user/User").User;
var UserMask = require("./../user/UserMask").UserMask;
var Team = require("./../user/Team").Team;
var Contextualizer = require("./../locales/Contextualizer").Contextualizer;
var Q = require("q");

/**
 * @class The App handles the reinitialization and loading of the app
 *        depending on which platform (Android, Chrome, web) the app is
 *        running, who is logged in etc.
 *
 * The App should be serializable to save state to local storage for the
 * next run.
 *
 * @name App
 *
 * @property {Authentication} authentication The auth member variable is an
 *           Authentication object permits access to the login and logout
 *           functions, and the database of users depending on whether the
 *           app is online or not. The authentication is the primary way to access the current user.
 *
 * @property {Corpus} corpus The corpus is a Corpus object which will permit
 *           access to the datum, the data lists and the sessions. The corpus feeds the
 *           search object with indexes and fields for advanced search, the
 *           corpus has datalists, has teams with permissions, has a
 *           confidentiality_encryption key, it's datum have sessions, its
 *           datalists and datum have export.
 *
 * @property {Search} search The current search details.
 *
 * @property {Session} currentSession The session that is currently open.
 *
 * @property {DataList} currentDataList The datalist that is currently open.
 * @extends FieldDBObject
 * @tutorial tests/app/AppTest.js
 * @constructs
 */
var App = function App(options) {
  this.debug("Constructing App ", options);
  FieldDBObject.apply(this, arguments);
  if (FieldDBObject.application) {
    this.warn("You shouldn't declare two apps at one time. Overwriting previous app.");
    this.debug("previous app", FieldDBObject.application);
  }
  FieldDBObject.application = this;

  this.speakersList = this.speakersList || new DataList({
    title: {
      default: "locale_All_Speakers"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "speakers"
  });
  this.consultantsList = this.consultantsList || new DataList({
    title: {
      default: "locale_All_Language_Consultants"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "consultants"
  });
  this.participantsList = this.participantsList || new DataList({
    title: {
      default: "locale_All_Participants"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "participants"
  });
  this.usersList = this.usersList || new DataList({
    title: {
      default: "locale_All_Users"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "users"
  });

  this.sessionsList = this.sessionsList || new DataList({
    title: {
      default: "locale_All_Elicitation_Sessions"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "sessions"
  });
  this.datalistsList = this.datalistsList || new DataList({
    title: {
      default: "locale_All_Datalists"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "datalists"
  });
  this.datumsList = this.datumsList || new DataList({
    title: {
      default: "locale_All_Data"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    // debugMode:true,
    api: "datums"
  });
  this.commentsList = this.commentsList || new DataList({
    title: {
      default: "All Comments"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "comments"
  });

  this.responsesList = this.responsesList || new DataList({
    title: {
      default: "List of Responses"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "responses"
  });
  this.experimentsList = this.experimentsList || new DataList({
    title: {
      default: "List of Experiment Results"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "experiments"
  });
  this.reportsList = this.reportsList || new DataList({
    title: {
      default: "List of Reports"
    },
    description: {
      default: "This list was automatically generated by looking in the corpus."
    },
    api: "reports"
  });

  this.importer = this.importer || null;
  this.search = this.search || null;
  this.currentDoc = this.currentDoc || null;
  this.team = this.team || null;
  this.corpus = this.corpus || null;
  this.thisyear = (new Date()).getFullYear();

  this._fieldDBtype = "App";
  var self = this;
  setTimeout(function() {
    self.warn("An app of type " + self.fieldDBtype + " has become automagically available to all fielddb objects");
  }, 500);

};

App.prototype = Object.create(FieldDBObject.prototype, /** @lends App.prototype */ {
  constructor: {
    value: App
  },

  authentication: {
    get: function() {
      return this._authentication || FieldDBObject.DEFAULT_OBJECT;
    },
    set: function(value) {
      if (value === this._authentication) {
        return;
      }
      if (!value) {
        delete this._authentication;
        return;
      } else {
        if (value && this.INTERNAL_MODELS && this.INTERNAL_MODELS["authentication"] && typeof this.INTERNAL_MODELS["authentication"] === "function" && value.constructor !== this.INTERNAL_MODELS["authentication"]) {
          this.debug("Parsing model: " + value);
          value = new this.INTERNAL_MODELS["authentication"](value);
        }
      }
      this._authentication = value;
    }
  },

  contextualizer: {
    get: function() {
      return this._contextualizer;
    },
    set: function(value) {
      if (value === this._contextualizer) {
        return;
      }
      if (!value) {
        delete this._contextualizer;
        return;
      } else {
        if (value && this.INTERNAL_MODELS && this.INTERNAL_MODELS["contextualizer"] && typeof this.INTERNAL_MODELS["contextualizer"] === "function" && value.constructor !== this.INTERNAL_MODELS["contextualizer"]) {
          this.debug("Parsing model: ", value);
          value = new this.INTERNAL_MODELS["contextualizer"](value);
          value.loadDefaults();
        }
      }
      this._contextualizer = value;
    }
  },

  contextualize: {
    value: function(value) {
      if (this._contextualizer) {
        return this._contextualizer.contextualize(value);
      } else {
        if (typeof value === "object" || value.default) {
          return value.default;
        }
        return value;
      }
    }
  },

  prefs: {
    get: function() {
      if (this.corpus && this.corpus.prefs) {
        return this.corpus.prefs;
      }
      if (this.authentication && this.authentication.user && this.authentication.user.prefs) {
        return this.authentication.user.prefs;
      }
    }
  },

  enterDecryptedMode: {
    value: function(loginDetails) {
      var deferred = Q.defer(),
        self = this;

      Q.nextTick(function() {
        if (this.corpus && typeof this.corpus.login === "function") {
          this.corpus.login(loginDetails).then(function() {

            self.decryptedMode = true;
            deferred.resolve(true);

          }, function(error) {
            deferred.reject(error);
          });
        } else {
          deferred.reject("User is not authenticated. Please log in.");
        }
      });
      return deferred.promise;
    }
  },

  load: {
    value: this.fetch
  },

  fetch: {
    value: function() {
      var self = this;

      /*
       * Load the user
       */
      if (!this.loadTheAppForTheFirstTime) {
        self.debug("Loading encrypted user");
        self.status = "Loading encrypted user...";
        var u = localStorage.getItem("encryptedUser");
        self.authentication.loadEncryptedUser(u, function(success, errors) {
          self.debug("loadEncryptedUser", success, errors);

          self.status = "Turning on continuous sync with your team server...";
          self.replicateContinuouslyWithCouch(function() {
            /*
             * Load the backbone objects
             */
            self.debug("Creating backbone objects");
            self.status = "Building dashboard objects...";
            self.createAppFieldDBObjects(self.couchConnection.pouchname, function() {

              /*
               * If you know the user, load their most recent
               * dashboard
               */
              self.debug("Loading the backbone objects");
              self.status = "Loading dashboard objects...";
              self.loadFieldDBObjectsByIdAndSetAsCurrentDashboard(
                self.authentication.userPrivate.mostRecentIds, function() {

                  self.debug("Starting the app");
                  self.startApp(function() {
                    self.showHelpOrNot();
                    self.stopSpinner();
                    self.router.renderDashboardOrNot(true);

                  });
                });
            });

          });

        });
      }

      try {
        window.onbeforeunload = this.warnUserAboutSavedSyncedStateBeforeUserLeaves;
      } catch (e) {
        this.warn("Cannot prevent the user from exiting if there are unsaved changes.");
      }
    }
  },

  // Internal models: used by the parse function
  INTERNAL_MODELS: {
    value: {
      corpus: Corpus,
      contextualizer: Contextualizer,
      authentication: Authentication,
      currentSession: Session,
      currentDataList: DataList,
      search: Search
    }
  },
  /*
   * This will be the only time the app should open the pouch.
   */
  changePouch: {
    value: function(couchConnection, callback) {
      if (!couchConnection || couchConnection === undefined) {
        this.debug("App.changePouch couchConnection must be supplied.");
        return;
      } else {
        this.debug("App.changePouch setting couchConnection: ", couchConnection);
        this.set("couchConnection", couchConnection);
      }
      //      self.bug("TODO set/validate that the the backone couchdb connection is the same as what user is asking for here");
      FieldDBObject.couch.urlPrefix = this.getCouchUrl(this.couchConnection, "");

      if (this.isChromeApp) {
        FieldDBObject.couch_connector.config.base_url = this.getCouchUrl(couchConnection, "");
        FieldDBObject.couch_connector.config.db_name = couchConnection.pouchname;
      } else {
        /* If the user is not in a chrome extension, the user MUST be on a url that corresponds with their corpus */
        try {
          var pieces = window.location.pathname.replace(/^\//, "").split("/");
          var pouchName = pieces[0];
          //Handle McGill server which runs out of a virtual directory
          if (pouchName === "corpus") {
            pouchName = pieces[1];
          }
          FieldDBObject.couch_connector.config.db_name = pouchName;
        } catch (e) {
          this.bug("Couldn't set the databse name off of the url, please report this.");
        }
      }

      if (typeof callback === "function") {
        callback();
      }
      return;



      // self.bug("TODO set/validate that the the pouch connection");
      // if (this.pouch === undefined) {
      //   // this.pouch = FieldDBObject.sync.pouch("https://localhost:6984/"
      //   // + couchConnection.pouchname);
      //   this.pouch = FieldDBObject.sync
      //     .pouch(OPrime.isAndroidApp() ? OPrime.touchUrl + couchConnection.pouchname : OPrime.pouchUrl + couchConnection.pouchname);
      // }
      // if (typeof callback === "function") {
      //   callback();
      // }
    }
  },
  /**
   * This function creates the backbone objects, and links them up so that
   * they are ready to be used in the views. This function should be called on
   * app load, either by main, or by welcome new user. This function should
   * not be called at any later time as it will break the connection between
   * the views and the models. To load different models into the app after it
   * has first loaded, use the loadFieldDBObjectsById function below.
   *
   * @param callback
   */
  createAppFieldDBObjects: {
    value: function(optionalpouchname, callback) {
      if (optionalpouchname === null) {
        optionalpouchname = "default";
      }

      if (FieldDBObject.couch_connector.config.db_name === "default") {
        this.bug("The app doesn't know which database its in. This is a problem.");
      }

      if (this.authentication.userPublic === undefined) {
        this.authentication.set("userPublic", new UserMask({
          pouchname: optionalpouchname
        }));
      }
      if (this.authentication.userPrivate === undefined) {
        this.authentication.set("userPrivate", new User());
      }
      var c = new Corpus({
        pouchname: optionalpouchname
      });
      this.set("corpus", c);

      this.set("currentSession", new Session({
        pouchname: optionalpouchname,
      }));

      this.set("currentDataList", new DataList({
        pouchname: optionalpouchname
      }));

      this.set("search", new Search({
        pouchname: optionalpouchname
      }));


      if (typeof callback === "function") {
        callback();
      }
    }
  },

  startApp: {
    value: function(callback) {
      /* Tell the app to render everything */
      this.render();

      if (typeof this.router === "function") {
        /* Tell the router to render the home screen divs */
        this.router = new Router();
        this.router.renderDashboardOrNot(true);

        FieldDBObject.history.start();
        if (typeof callback === "function") {
          this.debug("Calling back the startApps callback");
          callback();
        }
      }

    }
  },

  loading: {
    get: function() {
      return this._loading || this.fetching || false;
    },
    set: function(value) {
      if (value === this._loading) {
        return;
      }
      value = !!value;
      if (value === true) {
        this.status = "Loading dashboard";
      }
      this.loading = value;
    }
  },

  stopSpinner: {
    value: function() {
      this.loading = false;
    }
  },
  backUpUser: {
    value: function(callback) {
      var self = this;
      /* don't back up the public user, its not necessary the server doesn't modifications anyway. */
      if (self.authentication.userPrivate.username === "public" || self.authentication.userPrivate.username === "lingllama") {
        if (typeof callback === "function") {
          callback();
        }
      }
      this.saveAndInterConnectInApp(function() {
        //syncUserWithServer will prompt for password, then run the corpus replication.
        self.authentication.syncUserWithServer(function() {
          if (self.view) {
            self.toastUser("Backed up your user preferences with your authentication server, if you log into another device, your preferences will load.", "alert-info", "Backed-up:");
          }
          if (typeof callback === "function") {
            callback();
          }
        });
      });
    }
  },

  /**
   * Log the user into their corpus server automatically using cookies and post so that they can replicate later.
   * "http://localhost:5984/_session";
   *
   * References:
   * http://guide.couchdb.org/draft/security.html
   *
   * @param username this can come from a username field in a login, or from the User model.
   * @param password this comes either from the UserWelcomeView when the user logs in, or in the quick authentication view.
   * @param callback A function to call upon success, it receives the data back from the post request.
   */
  logUserIntoTheirCorpusServer: {
    value: function(couchConnection, username, password, succescallback, failurecallback) {
      var self = this;

      if (couchConnection === null || couchConnection === undefined) {
        couchConnection = this.couchConnection;
      }
      if (couchConnection === null || couchConnection === undefined) {
        this.bug("Bug: i couldnt log you into your couch database.");
      }

      /* if on android, turn on replication and don't get a session token */
      if (this.isTouchDBApp()) {
        Android.setCredentialsAndReplicate(couchConnection.pouchname,
          username, password, couchConnection.domain);
        this.debug("Not getting a session token from the users corpus server " + "since this is touchdb on android which has no idea of tokens.");
        if (typeof succescallback === "function") {
          succescallback();
        }
        return;
      }

      var couchurl = this.getCouchUrl(couchConnection, "/_session");
      var corpusloginparams = {};
      corpusloginparams.name = username;
      corpusloginparams.password = password;
      this.debug("Contacting your corpus server ", couchConnection, couchurl);

      this.couch.login({
        name: username,
        password: password,
        success: function(serverResults) {
          if (!serverResults) {
            self.bug("There was a problem logging you into your backup database, please report this.");
          }
          if (self.view) {
            self.toastUser(
              "I logged you into your team server automatically, your syncs will be successful.",
              "alert-info", "Online Mode:");
          }


          /* if in chrome extension, or offline, turn on replication */
          if (self.isChromeApp) {
            //TODO turn on pouch and start replicating and then redirect user to their user page(?)
            //            appself.replicateContinuouslyWithCouch();
          }

          if (typeof succescallback === "function") {
            succescallback(serverResults);
          }
        },
        error: function(serverResults) {
          self.debug("serverResults", serverResults);
          self.timeout(
            function() {
              //try one more time 5 seconds later
              FieldDBObject.couch.login({
                name: username,
                password: password,
                success: function(serverResults) {
                  if (self.view) {
                    self.toastUser(
                      "I logged you into your team server automatically, your syncs will be successful.",
                      "alert-info", "Online Mode:");
                  }
                  /* if in chrome extension, or offline, turn on replication */
                  if (self.isChromeApp) {
                    //TODO turn on pouch and start replicating and then redirect user to their user page(?)
                    //                      appself.replicateContinuouslyWithCouch();
                  }

                  if (typeof succescallback === "function") {
                    succescallback(serverResults);
                  }
                },
                error: function(serverResults) {
                  if (self.view) {
                    self.toastUser(
                      "I couldn't log you into your corpus. What does this mean? " + "This means you can't upload data to train an auto-glosser or visualize your morphemes. " + "You also can't share your data with team members. If your computer is online and you are" + " using the Chrome Store app, then this probably the side effect of a bug that we might not know about... please report it to us :) " + self.contextualizer.contactUs + " If you're offline you can ignore this warning, and sync later when you're online. ",
                      "alert-danger",
                      "Offline Mode:");
                  }
                  if (typeof failurecallback === "function") {
                    failurecallback("I couldn't log you into your corpus.");
                  }
                  self.debug(serverResults);
                  self.authentication.set(
                    "staleAuthentication", true);
                }
              });
            }, 5000);
        }
      });
    }
  },
  getCouchUrl: {
    value: function(couchConnection, couchdbcommand) {
      if (!couchConnection) {
        couchConnection = this.couchConnection;
        this.debug("Using the apps ccouchConnection", couchConnection);
      } else {
        this.debug("Using the couchConnection passed in,", couchConnection, this.couchConnection);
      }
      if (!couchConnection) {
        this.bug("The couch url cannot be guessed. It must be provided by the App. Please report this bug.");
      }
      return this.getCouchUrl(couchConnection, couchdbcommand);
    },
    /**
     * Synchronize to server and from database.
     */
    replicateContinuouslyWithCouch: function(successcallback,
      failurecallback) {
      var self = this;
      if (!self.pouch) {
        self.debug("Not replicating, no pouch ready.");
        if (typeof successcallback === "function") {
          successcallback();
        }
        return;
      }
      self.pouch(function(err, db) {
        var couchurl = self.getCouchUrl();
        if (err) {
          self.debug("Opening db error", err);
          if (typeof failurecallback === "function") {
            failurecallback();
          } else {
            this.bug("Opening DB error" + JSON.stringify(err));
            self.debug("Opening DB error" + JSON.stringify(err));
          }
        } else {
          self.debug("Opening db success", db);
          self.bug("TODO check to see if  needs a slash if replicating with pouch on " + couchurl);
          self.replicateFromCorpus(db, couchurl, function() {
            //turn on to regardless of fail or succeed
            self.replicateToCorpus(db, couchurl);
          }, function() {
            //turn on to regardless of fail or succeed
            self.replicateToCorpus(db, couchurl);
          });

          if (typeof successcallback === "function") {
            successcallback();
          }

        }
      });

    }
  },
  /**
   * Pull down corpus to offline pouch, if its there.
   */
  replicateOnlyFromCorpus: {
    value: function(couchConnection, successcallback, failurecallback) {
      var self = this;

      if (!self.pouch) {
        self.debug("Not replicating, no pouch ready.");
        if (typeof successcallback === "function") {
          successcallback();
        }
        return;
      }

      self.pouch(function(err, db) {
        var couchurl = self.getCouchUrl();
        if (err) {
          self.debug("Opening db error", err);
          if (typeof failurecallback === "function") {
            failurecallback();
          } else {
            self.bug("Opening DB error" + JSON.stringify(err));
            self.debug("Opening DB error" + JSON.stringify(err));
          }
        } else {
          db.replicate.from(couchurl, {
            continuous: false
          }, function(err, response) {
            self.debug("Replicate from " + couchurl, response, err);
            if (err) {
              if (typeof failurecallback === "function") {
                failurecallback();
              } else {
                self.bug("Corpus replicate from error" + JSON.stringify(err));
                self.debug("Corpus replicate from error" + JSON.stringify(err));
              }
            } else {
              self.debug("Corpus replicate from success", response);
              if (typeof successcallback === "function") {
                successcallback();
              }
            }
          });
        }
      });
    }
  },
  replicateToCorpus: {
    value: function(db, couchurl, success, failure) {
      var self = this;

      db.replicate.to(couchurl, {
        continuous: true
      }, function(err, response) {
        self.debug("Replicated to " + couchurl);
        self.debug(response);
        self.debug(err);
        if (err) {
          self.debug("replicate to db  error", err);
          if (typeof failure === "function") {
            failure();
          } else {
            self.bug("Database replicate to error" + JSON.stringify(err));
            self.debug("Database replicate to error" + JSON.stringify(err));
          }
        } else {
          self.debug("Database replicate to success", response);
          if (typeof success === "function") {
            success();
          } else {
            self.debug("Database replicating" + JSON.stringify(self.couchConnection));
          }

        }
      });
    }
  },
  replicateFromCorpus: {
    value: function(db, couchurl, succes, fail) {
      var self = this;

      db.replicate.from(couchurl, {
          continuous: true
        },
        function(err, response) {
          self.debug("Replicated from " + couchurl);
          self.debug(response);
          self.debug(err);
          if (err) {
            self.debug("replicate from db  error", err);
            if (typeof fail === "function") {
              fail();
            } else {
              self.bug("Database replicate from error" + JSON.stringify(err));
              self.debug("Database replicate from error" + JSON.stringify(err));
            }
          } else {
            self.debug("Database replicate from success",
              response);
            if (typeof succes === "function") {
              succes();
            } else {
              self.debug("Database replicating" + JSON.stringify(self.couchConnection));
            }

          }
        });
    }
  },

  processRouteParams: {
    value: function(routeParams) {
      var self = this;

      if (!routeParams) {
        this.warn("Route params are undefined, not loading anything");
        return;
      }
      this.routeParams = routeParams;

      /*
       * Handle precise routes
       */
      if (routeParams.importType) {
        self.debug("Creating an importer");
        this.importer = this.importer || new Import({
          importType: routeParams.importType
          // corpus: this.corpus
        });
      } else if (routeParams.reportType) {
        this.reportsList.filter = function(report) {
          if (routeParams.reportType.match(report.fieldDBtype.toLowerCase())) {
            return true;
          } else {
            return false;
          }
        };
      } else if (routeParams.speakerType) {
        this.speakersList.filter = function(speaker) {
          if (routeParams.speakerType.match(speaker.fieldDBtype.toLowerCase())) {
            return true;
          } else {
            return false;
          }
        };
      } else if (routeParams.searchQuery) {
        this.search = this.search || new Search({
          searchKeywords: routeParams.searchQuery
        });
      } else if (routeParams.docid) {
        if (this.doc && this.doc.save) {
          this.doc.bug("Switching to another document without saving...");
        }
        this.doc = new FieldDBObject({
          id: routeParams.docid
        });
      }

      /*
       * Letting the url determine which team is loaded
       */
      if (routeParams.team) {
        if (this.team && this.team.save) {
          this.team.bug("Switching to another team without saving...");
        }
        this.team = new Team({
          username: routeParams.team
        });

        /*
         * Letting the url determine which corpus is loaded
         */
        if (routeParams.corpusid) {
          this.currentCorpusDashboard = this.team.validateUsername(routeParams.team).username + "/" + this.team.sanitizeStringForFileSystem(routeParams.corpusid).toLowerCase();
          this.currentCorpusDashboardDBname = this.team.validateUsername(routeParams.team).username + "-" + this.team.sanitizeStringForFileSystem(routeParams.corpusid).toLowerCase();
          if (this.currentCorpusDashboardDBname.split("-").length < 2) {
            this.status = "Please try another url of the form teamname/corpusname " + this.currentCorpusDashboardDBname + " is not valid.";
            return;
          }

          this.team.dbname = this.currentCorpusDashboardDBname;
          if (this.corpus && this.corpus.save) {
            this.corpus.bug("Switching to another corpus without saving...");
          }
          if (!this.corpus || this.currentCorpusDashboardDBname !== this.corpus.dbname) {
            this.corpus = new Corpus({
              dbname: this.currentCorpusDashboardDBname
            });
          }
        }
      }

      /*
       * Fetching models if they are not complete
       */

      // FieldDBConnection.connect().done(function(userroles) {
      // self.application.authentication.userroles = userroles;
      if (this.team && !this.team.gravatar) {
        this.team.status = "Loading team details.";
        this.team.fetch(Corpus.prototype.BASE_DB_URL).then(function(result) {
          self.debug("Suceeded to download team\"s public details.", result);
          self.status = self.team.status = "Loaded team details.";
          self.render();
        }, function(result) {
          self.debug("Failed to download team details.", result);
          self.status = self.team.status = "Failed to download team details.";
          self.render();
        });
      }

      if (this.corpus && !this.corpus.title) {
        this.corpus.status = "Loading corpus details.";
        this.corpus.loadOrCreateCorpusByPouchName(this.corpus.dbname).then(function(result) {
          self.debug("Suceeded to download corpus details.", result);
          self.status = self.corpus.status = "Loaded corpus details.";
          if (self.application.importer) {
            self.application.importer.corpus = self.corpus;
          }
          self.render();
        }, function(result) {
          self.debug("Failed to download corpus details.", result);

          self.status = self.corpus.status = "Failed to download corpus details. Are you sure this is the corpus you wanted to see: " + self.corpus.dbname;
          self.loginDetails.username = self.team.username;
          self.render();
        }).catch(function(error) {
          self.warn("catch error", error);
        });
      }
    }
  },

  router: {
    value: Router
  },

  showHelpOrNot: {
    value: function() {
      var self = this;

      var username = this.authentication.userPrivate.username;
      if (username === "public") {
        //Dont show the help screen for the public user
        return;
      }
      var helpShownCount = localStorage.getItem(username + "helpShownCount") || 0;
      var helpShownTimestamp = localStorage.getItem(username + "helpShownTimestamp") || 0;

      /*
       * dont show the guide immediately if they are truely a new
       * user, let them see the dashboard before they wonder how
       * to use it. 60 seconds later, show the help.
       */
      if (helpShownTimestamp === 0) {
        self.helpCountReason = "Just in case you were wondering what all those buttons are for, check out Gretchen's Illustrated Guide to your dashboard! ";

        self.helpCount = 3 - helpShownCount;
        localStorage.setItem(username + "helpShownCount", ++helpShownCount);
        localStorage.setItem(username + "helpShownTimestamp", Date.now());
        self.timeout(function() {
          self.router.navigate("help/illustratedguide", {
            trigger: true
          });
        }, 60000);
        return;
      }

      /*
       * If this is not a brand new user:
       */
      var milisecondsSinceLastHelp = Date.now() - helpShownTimestamp;

      /* if its been more than 5 days, reset the help shown count to trigger the illustrated guide */
      if (milisecondsSinceLastHelp > 432000000 && helpShownTimestamp !== 0) {
        helpShownCount = 0;
        self.helpCountReason = "Welcome back! It's been more than 5 days since you opened the app. ";
      }
      if (helpShownCount > 3) {
        // do nothing
      } else {
        self.helpCount = 3 - helpShownCount;
        localStorage.setItem(username + "helpShownCount", ++helpShownCount);
        localStorage.setItem(username + "helpShownTimestamp", Date.now());
        self.router.navigate("help/illustratedguide", {
          trigger: true
        });
      }
    }
  },

  /**
     * This function is used to save the entire app state that is needed to load when the app is re-opened.
     * http://stackoverflow.com/questions/7794301/window-onunload-is-not-working-properly-in-chrome-browser-can-any-one-help-me
     *
     * $(window).on("beforeunload", function() {
        return "Your own message goes here...";
      });
     */
  warnUserAboutSavedSyncedStateBeforeUserLeaves: {
    value: function(e) {
      this.debug("warnUserAboutSavedSyncedStateBeforeUserLeaves", e);
      var returntext = "";
      if (this.view) {
        if (this.view.totalUnsaved.length >= 1) {
          returntext = "You have unsaved changes, click cancel to save them. \n\n";
        }
        if (this.view.totalUnsaved.length >= 1) {
          returntext = returntext + "You have unsynced changes, click cancel and then click the sync button to sync them. This is only important if you want to back up your data or if you are sharing your data with a team. \n\n";
        }
      }
      if (returntext === "") {
        return; //don't show a pop up
      } else {
        return "Either you haven't been using the app and Chrome wants some of its memory back, or you want to leave the app.\n\n" + returntext;
      }
    }
  },
  /**
   * Saves a json file via REST to a couchdb, must be online.
   *
   * @param bareActivityObject
   */
  addActivity: {
    value: function(bareActivityObject) {
      var self = this;

      bareActivityObject.verb = bareActivityObject.verb.replace("href=", "target='_blank' href=");
      bareActivityObject.directobject = bareActivityObject.directobject.replace("href=", "target='_blank' href=");
      bareActivityObject.indirectobject = bareActivityObject.indirectobject.replace("href=", "target='_blank' href=");
      bareActivityObject.context = bareActivityObject.context.replace("href=", "target='_blank' href=");

      self.debug("Saving activity: ", bareActivityObject);
      var backboneActivity = new Activity(bareActivityObject);

      var couchConnection = this.couchConnection;
      var activitydb = couchConnection.pouchname + "-activity_feed";
      if (bareActivityObject.teamOrPersonal !== "team") {
        activitydb = this.authentication.userPrivate.username + "-activity_feed";
        backboneActivity.attributes.user.set("gravatar", this.authentication.userPrivate.gravatar);
      }

      if (bareActivityObject.teamOrPersonal === "team") {
        self.currentCorpusTeamActivityFeed.addActivity(bareActivityObject);
      } else {
        self.currentUserActivityFeed.addActivity(bareActivityObject);
      }
    }
  },

  /**
   * This function sequentially saves first the session, datalist and then corpus. Its success callback is called if all saves succeed, its fail is called if any fail.
   * @param successcallback
   * @param failurecallback
   */
  saveAndInterConnectInApp: {
    value: function(successcallback, failurecallback) {
      var self = this;
      if (!failurecallback) {
        failurecallback = function() {
          self.bug("There was a bug/problem in the saveAndInterConnectInApp in App.js, somewhere along the save call. The Session is saved first, if it succeeds, then the datalist, then the corpus. The failure is somewhere along there.");
        };
      }
      self.currentSession.saveAndInterConnectInApp(function() {
        self.currentDataList.saveAndInterConnectInApp(function() {
          self.corpus.saveAndInterConnectInApp(function() {
            self.authentication.saveAndInterConnectInApp(function() {

              self.authentication.staleAuthentication = true;
              //              localStorage.setItem("mostRecentDashboard", JSON.stringify(self.authentication.userPrivate.mostRecentIds));
              if (self.view) {
                self.toastUser("Your dashboard has been saved, you can exit the app at anytime and return to this state.", "alert-success", "Exit at anytime:");
              }


              //appSelf.router.showDashboard();
              if (typeof successcallback === "function") {
                successcallback();
              }

            }, failurecallback);
          }, failurecallback);
        }, failurecallback);
      }, failurecallback);
    }
  },

  subscribers: {
    value: {
      any: []
    }
  },

  subscribe: {
    value: function(type, fn, context) {
      type = type || "any";
      fn = typeof fn === "function" ? fn : context[fn];

      if (typeof this.subscribers[type] === "undefined") {
        this.subscribers[type] = [];
      }
      this.subscribers[type].push({
        fn: fn,
        context: context || this
      });
    }
  },

  unsubscribe: {
    value: function(type, fn, context) {
      this.visitSubscribers("unsubscribe", type, fn, context);
    }
  },

  publish: {
    value: function(type, publication) {
      this.visitSubscribers("publish", type, publication);
    }
  },

  visitSubscribers: {
    value: function(action, type, arg, context) {
      var pubtype = type || "any";
      var subscribers = this.subscribers[pubtype];
      if (!subscribers || subscribers.length === 0) {
        this.debug(pubtype + ": There were no subscribers.");
        return;
      }
      var i;
      var maxUnsubscribe = subscribers ? subscribers.length - 1 : 0;
      var maxPublish = subscribers ? subscribers.length : 0;

      if (action === "publish") {
        // count up so that older subscribers get the message first
        for (i = 0; i < maxPublish; i++) {
          if (subscribers[i]) {
            // TODO there is a bug with the subscribers they are getting lost, and
            // it is trying to call fn of undefiend. this is a workaround until we
            // figure out why subscribers are getting lost. Update: i changed the
            // loop to count down and remove subscribers from the ends, now the
            // size of subscribers isnt changing such that the subscriber at index
            // i doesnt exist.
            subscribers[i].fn.call(subscribers[i].context, arg);
          }
        }
        this.debug("Visited " + subscribers.length + " subscribers.");

      } else {

        // count down so that subscribers index exists when we remove them
        for (i = maxUnsubscribe; i >= 0; i--) {
          try {
            if (!subscribers[i].context) {
              this.debug("This subscriber has no context. should we remove it? " + i);
            }
            if (subscribers[i].context === context) {
              var removed = subscribers.splice(i, 1);
              this.debug("Removed subscriber " + i + " from " + type, removed);
            } else {
              this.debug(type + " keeping subscriber " + i, subscribers[i].context);
            }
          } catch (e) {
            this.debug("problem visiting Subscriber " + i, subscribers);
          }
        }
      }
    }
  },

  isAndroidApp: {
    get: function() {

      // Development tablet navigator.userAgent:
      // Mozilla/5.0 (Linux; U; Android 3.0.1; en-us; gTablet Build/HRI66)
      // AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13
      // this.debug("The user agent is " + navigator.userAgent);
      try {
        return navigator.userAgent.indexOf("OfflineAndroidApp") > -1;
      } catch (e) {
        this.warn("Cant determine app type isAndroidApp, " + e);
        return false;
      }
    }
  },

  isAndroid4: {
    get: function() {
      try {
        return navigator.userAgent.indexOf("Android 4") > -1;
      } catch (e) {
        this.warn("Cant determine app type isAndroid4, " + e);
        return false;
      }
    }
  },

  isChromeApp: {
    get: function() {
      try {
        return window.location.href.indexOf("chrome-extension") > -1;
      } catch (e) {
        this.warn("Cant determine app type isChromeApp, " + e);
        return false;
      }
    }
  },

  isCouchApp: {
    get: function() {
      try {
        return window.location.href.indexOf("_design/pages") > -1;
      } catch (e) {
        this.warn("Cant determine app type isCouchApp, " + e);
        return false;
      }
    }
  },

  isTouchDBApp: {
    get: function() {
      try {
        return window.location.href.indexOf("localhost:8128") > -1;
      } catch (e) {
        this.warn("Cant determine app type isTouchDBApp, " + e);
        return false;
      }
    }
  },

  isNodeJSApp: {
    get: function() {
      try {
        return window.location.href !== undefined;
      } catch (e) {
        // this.debug("Cant access window, app type isNodeJSApp, ", e);
        return true;
      }
    }
  },

  isBackboneCouchDBApp: {
    get: function() {
      return false;
    }
  },

  /**
   * If not running offline on an android or in a chrome extension, assume we are
   * online.
   *
   * @returns {Boolean} true if not on offline Android or on a Chrome Extension
   */
  isOnlineOnly: {
    get: function() {
      return !this.isAndroidApp && !this.isChromeApp;
    }
  }


});
exports.App = App;
