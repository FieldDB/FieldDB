function(head, req) {\n  start({\n    'headers': {\n      'Content-Type': 'text/csv'\n    }\n  });\n\n  /*  TODO: Use AJAX to retrieve field names*/\n  var datum_fields = {'rows':[{'key':{'original':'comments','typed':'comments_t'},'value':26},{'key':{'original':'consultants','typed':'consultants_t'},'value':72},{'key':{'original':'dateElicited','typed':'dateElicited_t'},'value':144},{'key':{'original':'gloss','typed':'gloss_t'},'value':72},{'key':{'original':'goal','typed':'goal_t'},'value':72},{'key':{'original':'morphemes','typed':'morphemes_t'},'value':72},{'key':{'original':'tags','typed':'tags_t'},'value':55},{'key':{'original':'translation','typed':'translation_t'},'value':71},{'key':{'original':'utterance','typed':'utterance_t'},'value':72},{'key':{'original':'validationStatus','typed':'validationStatus_t'},'value':72}]};\n  var datumFieldsAsLuceneSchema = [];\n  var datumFields = [];\n\n  /*  Rearrange the retrieved data fields into an array, and then send the\n  joined array as column headers.*/\n  for (var i in datum_fields.rows) {\n    datumFieldsAsLuceneSchema.push(datum_fields.rows[i].key.typed);\n    datumFields.push(datum_fields.rows[i].key.original);\n  }\n\n  send('_id,' + datumFieldsAsLuceneSchema.join(',') + '\\\\n');\n\n  /*  Now, process each row returned from the original map/reduce in order\n  to create data rows for the CSV file.*/\n  while (row = getRow()) {\n\n    var rowAsCsv = row.value;\n    for (var field = 0; field < datumFields.length; field++) {\n      rowAsCsv += ',';\n      if (row.key[datumFields[field]]) {\n        rowAsCsv += '\\\"' + row.key[datumFields[field]] + '\\\"';\n      } else {\n        rowAsCsv += '';\n      }\n    }\n    send(rowAsCsv + '\\\\n');\n  }\n}\n